// Generated by CoffeeScript 1.8.0
(function() {
  this.initScene = function(viewService, fileService, eye, orbit, lightEye, lightOrbit) {
    var LIGHT, MATERIAL, ambientProduct, camera, canvasId, diffuseProduct, light, mouse, shaderProgram, specularProduct;
    canvasId = "main-canvas";
    window.scene = new window.Scene(canvasId);
    window.SHADER_DEFINITIONS = [
      {
        attributes: {
          "vPosition": new Attribute("vPosition", 'attribute'),
          "vNormal": new Attribute("vNormal", 'attribute')
        },
        uniforms: {
          "CameraProjection": new Attribute("CameraProjection", 'uniform', window.gl.uniformMatrix4fv, 'mat4fv'),
          "CameraView": new Attribute("CameraView", 'uniform', window.gl.uniformMatrix4fv, 'mat4fv'),
          "Model": new Attribute("Model", 'uniform', window.gl.uniformMatrix4fv, 'mat4fv'),
          "AmbientProduct": new Attribute("AmbientProduct", 'uniform', window.gl.uniform4fv, '4fv'),
          "DiffuseProduct": new Attribute("DiffuseProduct", 'uniform', window.gl.uniform4fv, '4fv'),
          "SpecularProduct": new Attribute("SpecularProduct", 'uniform', window.gl.uniform4fv, '4fv'),
          "LightPosition": new Attribute("LightPosition", 'uniform', window.gl.uniform4fv, '4fv'),
          "Shininess": new Attribute("Shininess", 'uniform', window.gl.uniform1f, '1f'),
          "LightProjection": new Attribute("LightProjection", 'uniform', window.gl.uniformMatrix4fv, 'mat4fv'),
          "LightView": new Attribute("LightView", 'uniform', window.gl.uniformMatrix4fv, 'mat4fv'),
          "ShadowMap": new Attribute("ShadowMap", 'uniform', window.gl.uniform1i, '1i'),
          "RenderingZBuffer": new Attribute("RenderingZBuffer", 'uniform', window.gl.uniform1i, '1i')
        }
      }
    ];
    camera = new window.Camera(viewService, eye, orbit);
    light = new window.Camera(viewService, lightEye, lightOrbit);
    shaderProgram = new window.ShaderProgram(0);
    LIGHT = {
      position: [1.5, 1.5, 2.0, 1.0],
      ambient: [0.8, 0.8, 0.8, 1.0],
      diffuse: [1.0, 1.0, 1.0, 1.0],
      specular: [1.0, 1.0, 1.0, 1.0]
    };
    MATERIAL = {
      ambient: [1.0, 0.6, 0.0, 1.0],
      diffuse: [1.0, 0.8, 0.0, 1.0],
      specular: [1.0, 0.8, 0.0, 1.0],
      shininess: 100.0
    };
    ambientProduct = vec4.create();
    diffuseProduct = vec4.create();
    specularProduct = vec4.create();
    vec4.mul(ambientProduct, LIGHT.ambient, MATERIAL.ambient);
    vec4.mul(diffuseProduct, LIGHT.diffuse, MATERIAL.diffuse);
    vec4.mul(specularProduct, LIGHT.specular, MATERIAL.specular);
    shaderProgram.setAttrValue("LightPosition", LIGHT.position);
    shaderProgram.setAttrValue("AmbientProduct", ambientProduct);
    shaderProgram.setAttrValue("DiffuseProduct", diffuseProduct);
    shaderProgram.setAttrValue("SpecularProduct", specularProduct);
    shaderProgram.setAttrValue("Shininess", MATERIAL.shininess);
    mouse = new window.Mouse();
    window.scene.init(camera, light, shaderProgram, mouse);
  };

  this.Scene = (function() {
    function Scene(canvasId, camera, light, shaderProgram, mouse, models) {
      this.camera = camera;
      this.light = light;
      this.shaderProgram = shaderProgram;
      this.mouse = mouse;
      this.models = models;
      this.canvas = document.getElementById(canvasId);
      this.colorIdSequence = 0;
      this.initGL();
      this.models = new Array();
    }

    Scene.prototype.init = function(camera, light, shaderProgram, mouse) {
      this.camera = camera;
      this.light = light;
      this.shaderProgram = shaderProgram;
      this.mouse = mouse;
      this.initShader();
      this.initZBuffer();
      this.initEventHandlers();
      return this.drawScene();
    };

    Scene.prototype.initGL = function() {
      var e, gl;
      this.resize();
      try {
        gl = this.canvas.getContext("experimental-webgl");
        gl = WebGLDebugUtils.makeDebugContext(gl);
        gl.viewportWidth = this.canvas.width;
        gl.viewportHeight = this.canvas.height;
      } catch (_error) {
        e = _error;
        console.log(e);
      }
      if (gl == null) {
        alert("Could not initialise WebGL, sorry :-(");
      }
      gl.clearColor(0.7, 0.7, 0.7, 1.0);
      gl.enable(gl.DEPTH_TEST);
      return window.gl = gl;
    };

    Scene.prototype.initShader = function() {
      return this.shaderProgram.init();
    };

    Scene.prototype.initZBuffer = function() {
      var depthFrameBuffer, depthRenderBuffer, depthTexture, gl, texSize;
      gl = window.gl;
      texSize = $(this.canvas).width();
      depthTexture = gl.createTexture();
      gl.bindTexture(gl.TEXTURE_2D, depthTexture);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
      gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, texSize, texSize, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);
      depthFrameBuffer = gl.createFramebuffer();
      gl.bindFramebuffer(gl.FRAMEBUFFER, depthFrameBuffer);
      gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, depthTexture, 0);
      gl.bindTexture(gl.TEXTURE_2D, depthTexture);
      gl.enable(gl.DEPTH_TEST);
      depthRenderBuffer = gl.createRenderbuffer();
      gl.bindRenderbuffer(gl.RENDERBUFFER, depthRenderBuffer);
      gl.renderbufferStorage(gl.RENDERBUFFER, gl.DEPTH_COMPONENT16, texSize, texSize);
      gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.DEPTH_ATTACHMENT, gl.RENDERBUFFER, depthRenderBuffer);
      if (this.framebufferNotComplete()) {
        alert("this combination of attachments does not work");
      }
      this.depthFrameBuffer = depthFrameBuffer;
      this.depthRenderBuffer = depthRenderBuffer;
      this.depthTexture = depthTexture;
      this.shaderProgram.setAttrValue("ShadowMap", depthTexture);
      gl.activeTexture(gl.TEXTURE0);
      return gl.bindTexture(gl.TEXTURE_2D, depthTexture);
    };

    Scene.prototype.resize = function() {
      var canvas, canvasHeight, canvasWidth, fullscreen, parentWidth;
      canvas = $(this.canvas);
      parentWidth = canvas.parent().width();
      canvas.width(parentWidth);
      canvas.height(parentWidth);
      canvas.attr('width', parentWidth);
      canvas.attr('height', parentWidth);
      canvasWidth = canvas.width();
      canvasHeight = canvas.height();
      fullscreen = $("#fullscreen");
      fullscreen.css('top', 3 - canvas.height());
      return fullscreen.css('left', canvas.width() - fullscreen.width() - 3 - 26);
    };

    Scene.prototype.drawScene = function() {
      var gl;
      gl = window.gl;
      this.shaderProgram.setAttrValue("RenderingZBuffer", true);
      gl.bindFramebuffer(gl.FRAMEBUFFER, this.depthFrameBuffer);
      this.draw();
      this.shaderProgram.setAttrValue("RenderingZBuffer", false);
      gl.bindFramebuffer(gl.FRAMEBUFFER, null);
      this.draw();
      requestAnimationFrame(this.drawScene.bind(this));
    };

    Scene.prototype.draw = function() {
      var cameraProjection, cameraView, gl, lightProjection, lightView, model, _i, _len, _ref, _results;
      gl = window.gl;
      gl.viewport(0, 0, $(this.canvas).width(), $(this.canvas).height());
      gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
      cameraProjection = this.camera.getProjectionMatrix();
      this.shaderProgram.setAttrValue('CameraProjection', cameraProjection);
      cameraView = this.camera.getViewMatrix();
      this.shaderProgram.setAttrValue('CameraView', cameraView);
      lightProjection = this.light.getProjectionMatrix("Orthographic");
      this.shaderProgram.setAttrValue('LightProjection', lightProjection);
      lightView = this.light.getViewMatrix();
      this.shaderProgram.setAttrValue('LightView', lightView);
      _ref = this.models;
      _results = [];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        model = _ref[_i];
        if (model.active) {
          _results.push(model.draw(this.shaderProgram));
        } else {
          _results.push(void 0);
        }
      }
      return _results;
    };

    Scene.prototype.initEventHandlers = function() {
      document.oncontextmenu = function() {
        return false;
      };
      $(window).resize(this.resize.bind(this));
      $(this.canvas).mousemove(this.onMouseMove.bind(this));
      $(this.canvas).mousedown(this.mouse.onClick.bind(this.mouse));
      return $(this.canvas).mouseup(this.mouse.onClick.bind(this.mouse));
    };

    Scene.prototype.onMouseMove = function(event, target) {
      var mouse;
      mouse = this.mouse;
      mouse.onMove(event, target);
      if (mouse.isDown && mouse.isDragging) {
        this.camera.updateRotation();
        return quat.copy(this.light.orbitRot, this.camera.orbitRot);
      }
    };

    Scene.prototype.getNextColorId = function() {
      this.colorIdSequence += 1;
      return this.colorIdSequence;
    };

    Scene.prototype.colorIdToUint8Array = function(colorId) {
      var colorIdUint;
      colorIdUint = new Uint8Array(4);
      colorIdUint[0] = colorId % 256;
      colorIdUint[1] = Math.floor(colorId / 256) % 256;
      colorIdUint[2] = Math.floor(colorId / (256 * 256)) % 256;
      colorIdUint[3] = 255;
      return colorIdUint;
    };

    Scene.prototype.framebufferNotComplete = function() {
      return window.gl.checkFramebufferStatus(window.gl.FRAMEBUFFER) !== window.gl.FRAMEBUFFER_COMPLETE;
    };

    Scene.prototype.addModel = function(file) {
      return this.models.push(new window.Model(file.obj));
    };

    Scene.prototype.selectedModelsChange = function(files) {
      var file, model, _i, _len, _results;
      _results = [];
      for (_i = 0, _len = files.length; _i < _len; _i++) {
        file = files[_i];
        _results.push((function() {
          var _j, _len1, _ref, _results1;
          _ref = this.models;
          _results1 = [];
          for (_j = 0, _len1 = _ref.length; _j < _len1; _j++) {
            model = _ref[_j];
            if (model.modelId === file.obj.modelId) {
              _results1.push(model.active = file.isSelected);
            } else {
              _results1.push(void 0);
            }
          }
          return _results1;
        }).call(this));
      }
      return _results;
    };

    return Scene;

  })();

  this.Mouse = (function() {
    function Mouse() {
      this.x = 0;
      this.y = 0;
      this.deltaX = 0;
      this.deltaY = 0;
      this.isDown = false;
      this.isDragging = false;
    }

    Mouse.prototype.onMove = function(event, target) {
      var oldX, oldY;
      this.isDragging = true;
      oldX = this.x;
      oldY = this.y;
      this.updatePosition(event, target);
      this.deltaX = this.x - oldX;
      return this.deltaY = this.y - oldY;
    };

    Mouse.prototype.onClick = function(event, target) {
      switch (event.which) {
        case 1:
          this.isDown = !this.isDown;
          break;
        case 3:
          this.isDown = !this.isDown;
          break;
        case 2:
          this.isDown = !this.isDown;
          break;
        default:
          alert('You have a strange Mouse!');
      }
      if (!this.isDragging && !this.isDown) {
        this.clicked = !this.clicked;
      }
      this.isDragging = false;
      if (this.isDown) {
        return this.updatePosition(event, target);
      }
    };

    Mouse.prototype.updatePosition = function(event, target) {
      var parentOffset;
      if (document.mozFullScreen || document.webkitIsFullScreen) {
        this.x = event.pageX;
        return this.y = $(window.scene.canvas).height() - event.pageY;
      } else {
        parentOffset = $(window.scene.canvas).parent().offset();
        this.x = Math.round(event.pageX - parentOffset.left);
        return this.y = $(target).height() - Math.round(event.pageY - parentOffset.top);
      }
    };

    return Mouse;

  })();

  this.Camera = (function() {
    function Camera(viewService, eye, orbit, eyeRot, orbitRot, direction) {
      this.viewService = viewService;
      this.eye = eye;
      this.orbit = orbit;
      this.eyeRot = eyeRot;
      this.orbitRot = orbitRot;
      this.direction = direction;
      this.direction = {
        x: [1, 0, 0],
        y: [0, 1, 0]
      };
      this.eyeRot = quat.create();
      this.orbitRot = quat.create();
      this.lookAt();
      this.setDirection();
    }

    Camera.prototype.lookAt = function() {
      var lookAtMatrix, lookAtRotMatrix;
      lookAtMatrix = mat4.create();
      lookAtRotMatrix = mat4.create();
      mat4.lookAt(lookAtMatrix, this.eye, this.orbit, this.direction.y);
      mat3.fromMat4(lookAtRotMatrix, lookAtMatrix);
      return quat.fromMat3(this.eyeRot, lookAtRotMatrix);
    };

    Camera.prototype.setDirection = function() {
      var desiredUp, forward, right, up;
      desiredUp = this.direction.y;
      right = vec3.create();
      up = vec3.create();
      forward = vec3.create();
      vec3.sub(forward, this.orbit, this.eye);
      vec3.normalize(forward, forward);
      vec3.normalize(desiredUp, desiredUp);
      vec3.cross(right, forward, desiredUp);
      vec3.normalize(right, right);
      vec3.cross(up, right, forward);
      vec3.normalize(up, up);
      this.direction.x = right;
      return this.direction.y = up;
    };

    Camera.prototype.getProjectionMatrix = function(selectView) {
      var canvas, canvasRatio, deviation, heightDev, orthoHeight, orthoRatio, orthoWidth, outMatrix, view, widthDev;
      outMatrix = mat4.create();
      canvas = $(window.scene.canvas);
      view = this.viewService.getSelectedViewForWebGL(selectView);
      canvasRatio = canvas.width() / canvas.height();
      switch (view.viewType) {
        case 'Perspective':
          mat4.perspective(outMatrix, view.fovy, view.ratio * canvasRatio, view.near, view.far);
          break;
        case 'Orthographic':
          orthoHeight = Math.abs(view.top - view.bottom);
          orthoWidth = Math.abs(view.left - view.right);
          orthoRatio = orthoWidth / orthoHeight;
          deviation = Math.abs(canvasRatio - orthoRatio) / 2;
          if (orthoRatio > canvasRatio) {
            heightDev = orthoWidth * deviation;
            widthDev = 0.0;
          } else {
            heightDev = 0.0;
            widthDev = orthoHeight * deviation;
          }
          mat4.ortho(outMatrix, view.left - widthDev, view.right + widthDev, view.bottom - heightDev, view.top + heightDev, view.near, view.far);
          break;
        default:
          alert("Unknown view type: ${view.viewType}\nView not set.");
      }
      return outMatrix;
    };

    Camera.prototype.getViewMatrix = function() {
      var eye, eyeMagnitude, eyeMatrix, orbitMatrix, outMatrix;
      eye = vec3.create();
      vec3.sub(eye, this.eye, this.orbit);
      eyeMagnitude = this.getMagnitude(eye);
      eyeMatrix = mat4.create();
      orbitMatrix = mat4.create();
      mat4.fromRotationTranslation(orbitMatrix, this.orbitRot, this.orbit);
      mat4.fromRotationTranslation(eyeMatrix, this.eyeRot, [0, 0, -eyeMagnitude]);
      outMatrix = mat4.create();
      mat4.multiply(outMatrix, eyeMatrix, orbitMatrix);
      return outMatrix;
    };

    Camera.prototype.getMagnitude = function(vec) {
      return Math.sqrt(vec[0] * vec[0] + vec[1] * vec[1] + vec[2] * vec[2]);
    };

    Camera.prototype.updateRotation = function() {
      var mouse, rotPitch, rotYaw;
      mouse = window.scene.mouse;
      rotYaw = quat.create();
      quat.setAxisAngle(rotYaw, this.direction.y, this.toRadians(mouse.deltaX));
      quat.multiply(this.orbitRot, rotYaw, this.orbitRot);
      quat.normalize(this.orbitRot, this.orbitRot);
      rotPitch = quat.create();
      quat.setAxisAngle(rotPitch, this.direction.x, -this.toRadians(mouse.deltaY));
      quat.multiply(this.orbitRot, rotPitch, this.orbitRot);
      return quat.normalize(this.orbitRot, this.orbitRot);
    };

    Camera.prototype.toRadians = function(degrees) {
      return degrees * (Math.PI / 180);
    };

    return Camera;

  })();

  this.Model = (function() {
    function Model(fileObj) {
      this.modelId = fileObj.modelId;
      this.active = fileObj.active;
      this.vertices = fileObj.vertices;
      this.normals = fileObj.normals;
      this.faces = fileObj.faces;
      this.lineFaces = fileObj.lineFaces;
      this.translation = fileObj.translation;
      this.rotation = fileObj.rotation;
      this.scale = fileObj.scale;
      this.colorId = window.scene.getNextColorId();
      this.colorId.asUint8Array = window.scene.colorIdToUint8Array(this.colorId);
      this.uniforms = new Array();
      this.buffer();
    }

    Model.prototype.buffer = function() {
      var gl;
      gl = window.gl;
      this.vertices.buffer = gl.createBuffer();
      this.normals.buffer = gl.createBuffer();
      gl.bindBuffer(gl.ARRAY_BUFFER, this.vertices.buffer);
      gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(this.vertices), gl.STATIC_DRAW);
      gl.bindBuffer(gl.ARRAY_BUFFER, this.normals.buffer);
      gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(this.normals), gl.STATIC_DRAW);
      this.faces.buffer = gl.createBuffer();
      gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.faces.buffer);
      gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(this.faces), gl.STATIC_DRAW);
      this.lineFaces.buffer = gl.createBuffer();
      gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.lineFaces.buffer);
      return gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(this.lineFaces), gl.STATIC_DRAW);
    };

    Model.prototype.addUniform = function(uniform) {
      return uniforms.push(uniform);
    };

    Model.prototype.getModelMatrix = function() {
      var modelMatrix;
      modelMatrix = mat4.create();
      mat4.mul(modelMatrix, modelMatrix, this.translation);
      mat4.mul(modelMatrix, modelMatrix, this.rotation);
      mat4.mul(modelMatrix, modelMatrix, this.scale);
      return modelMatrix;
    };

    Model.prototype.draw = function() {
      var gl, shaderProgram, vNormalLoc, vPositionLoc;
      gl = window.gl;
      shaderProgram = window.scene.shaderProgram;
      shaderProgram.setAttrValue("Model", this.getModelMatrix());
      vPositionLoc = shaderProgram.getAttr("vPosition", "attribute").location;
      gl.bindBuffer(gl.ARRAY_BUFFER, this.vertices.buffer);
      gl.vertexAttribPointer(vPositionLoc, 3, gl.FLOAT, false, 0, 0);
      vNormalLoc = shaderProgram.getAttr("vNormal", "attribute").location;
      gl.bindBuffer(gl.ARRAY_BUFFER, this.normals.buffer);
      gl.vertexAttribPointer(vNormalLoc, 3, gl.FLOAT, false, 0, 0);
      gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.faces.buffer);
      shaderProgram.setUniforms();
      return gl.drawElements(gl.TRIANGLES, this.faces.length, gl.UNSIGNED_SHORT, 0);
    };

    return Model;

  })();

  this.Attribute = (function() {
    function Attribute(varName, attrType, setAttrFunc, attrValueType, location, attrValue) {
      this.varName = varName;
      this.attrType = attrType;
      this.setAttrFunc = setAttrFunc;
      this.attrValueType = attrValueType;
      this.location = location;
      this.attrValue = attrValue;
    }

    Attribute.prototype.initLocation = function(shaderProgram) {
      if (this.attrType === 'attribute') {
        this.location = window.gl.getAttribLocation(shaderProgram, this.varName);
        return window.gl.enableVertexAttribArray(this.location);
      } else {
        return this.location = window.gl.getUniformLocation(shaderProgram, this.varName);
      }
    };

    Attribute.prototype.setValueForShader = function() {
      var gl;
      gl = window.gl;
      switch (this.attrValueType) {
        case 'mat4fv':
          return gl.uniformMatrix4fv(this.location, false, this.attrValue);
        case '4fv':
          return gl.uniform4fv(this.location, this.attrValue);
        case '1f':
          return gl.uniform1f(this.location, this.attrValue);
        case '1i':
          return gl.uniform1i(this.location, this.attrValue);
        default:
          return alert("Attribute: " + this.varName + " was not properly initialised: " + this.attrValue);
      }
    };

    return Attribute;

  })();

  this.ShaderProgram = (function() {
    function ShaderProgram(shaderDefId) {
      this.program = null;
      this.shaderDef = window.SHADER_DEFINITIONS[shaderDefId];
      this.vertexShader = this.getShader("" + shaderDefId + "-shader-vs");
      this.fragmentShader = this.getShader("" + shaderDefId + "-shader-fs");
    }

    ShaderProgram.prototype.init = function() {
      var attribute, gl, name, shaderProgram, uniform, _ref, _ref1;
      gl = window.gl;
      shaderProgram = gl.createProgram();
      gl.attachShader(shaderProgram, this.vertexShader);
      gl.attachShader(shaderProgram, this.fragmentShader);
      gl.linkProgram(shaderProgram);
      if (this.shaderInitError(shaderProgram)) {
        alert("Could not initialise shaders");
      }
      gl.useProgram(shaderProgram);
      _ref = this.shaderDef.attributes;
      for (name in _ref) {
        attribute = _ref[name];
        attribute.initLocation(shaderProgram);
      }
      _ref1 = this.shaderDef.uniforms;
      for (name in _ref1) {
        uniform = _ref1[name];
        uniform.initLocation(shaderProgram);
      }
      return this.program = shaderProgram;
    };

    ShaderProgram.prototype.getShader = function(htmlId) {
      var gl, k, shader, shaderScript, str;
      gl = window.gl;
      shaderScript = document.getElementById(htmlId);
      if (shaderScript == null) {
        return null;
      }
      str = '';
      k = shaderScript.firstChild;
      while (k) {
        if (k.nodeType === 3) {
          str += k.textContent;
        }
        k = k.nextSibling;
      }
      shader = (function() {
        switch (shaderScript.type) {
          case 'x-shader/x-vertex':
            return gl.createShader(gl.VERTEX_SHADER);
          case 'x-shader/x-fragment':
            return gl.createShader(gl.FRAGMENT_SHADER);
          default:
            return null;
        }
      })();
      if (shader == null) {
        return null;
      }
      gl.shaderSource(shader, str);
      gl.compileShader(shader);
      if (this.shaderCompilationError(shader)) {
        alert(gl.getShaderInfoLog(shader));
      }
      return shader;
    };

    ShaderProgram.prototype.shaderInitError = function(shaderProgram) {
      return !gl.getProgramParameter(shaderProgram, gl.LINK_STATUS);
    };

    ShaderProgram.prototype.shaderCompilationError = function(shader) {
      return !gl.getShaderParameter(shader, gl.COMPILE_STATUS);
    };

    ShaderProgram.prototype.setUniforms = function() {
      var name, uniform, _ref, _results;
      _ref = this.shaderDef.uniforms;
      _results = [];
      for (name in _ref) {
        uniform = _ref[name];
        _results.push(uniform.setValueForShader());
      }
      return _results;
    };

    ShaderProgram.prototype.setAttrValue = function(name, value) {
      return this.shaderDef.uniforms[name].attrValue = value;
    };

    ShaderProgram.prototype.getAttr = function(name, type) {
      if (type === "attribute") {
        return this.shaderDef.attributes[name];
      } else {
        return this.shaderDef.uniforms[name];
      }
    };

    return ShaderProgram;

  })();

}).call(this);

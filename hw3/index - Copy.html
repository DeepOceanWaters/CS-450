<!DOCTYPE html>
<html>
<head>
	<title>CS 450: HW3</title>

	<link rel="stylesheet" type="text/css" href="css/bootstrap.css"/>
	<link rel="stylesheet" type="text/css" href="css/cs450-hw.css"/>
    <script type="text/javascript" src="js/jquery.js"></script>
  	<script type="text/javascript" src="js/bootstrap.js"></script>
  	<script type="text/javascript" src="js/gl-matrix-min.js"></script>
  	<script type="text/javascript" src="js/webgl-utils.js"></script>
    <script type="text/javascript" src="js/angular.js"></script>
	<script type="text/javascript" src="js/angular/services/viewService.js"></script>
    <script type="text/javascript" src="js/angular/services/fileService.js"></script>
	<script type="text/javascript" src="js/angular/controllers/viewCtrl.js"></script>
    <script type="text/javascript" src="js/angular/controllers/fileCtrl.js"></script>
    <script type="text/javascript" src="js/angular/controllers/canvasCtrl.js"></script>
    <script type="text/javascript" src="js/angular/app.js"></script>
  	<script id="shader-fs" type="x-shader/x-fragment">
     	precision mediump float;

        varying float steps;
        varying float pass_Value;
        varying float eye_Value;
        uniform bool OffScreen;
        uniform sampler2D ShadowMap;
        varying vec4 pickingColor;
        varying vec4 position;
        varying vec4 shadowCoord;
     	varying vec4 color;
        uniform vec2 TexSize;

        vec3 hueToRGB(float h)
        {
            //h = fract(h) * 6.0;
            //vec3 rgb;
            //rgb.r = clamp(abs(3.0 - h)-1.0, 0.0, 1.0);
            //rgb.g = clamp(2.0 - abs(2.0 - h), 0.0, 1.0);
            //rgb.b = clamp(2.0 - abs(4.0 - h), 0.0, 1.0);
            //return rgb;
            vec3 rgb;
            rgb.r = clamp(color[0] - color[0]*h, 0.0, 1.0);
            rgb.g = clamp(color[1] - color[1]*h, 0.0, 1.0);
            rgb.b = clamp(color[2] - color[2]*h, 0.0, 1.0);
            return rgb;
        }
        
        vec3 heat(float x)
        {
            return hueToRGB(2.0/3.0-(2.0/3.0)*clamp(x,0.0,1.0));
        }

        vec4 pack_float(float value)
        {
            const vec4 bit_shift = vec4(256.0*256.0*256.0, 256.0*256.0, 256.0, 1.0);
            const vec4 bit_mask  = vec4(0.0, 1.0/256.0, 1.0/256.0, 1.0/256.0);
            vec4 res = fract(value * bit_shift);
            res -= res.xxyz * bit_mask;
            return res;
        }

        float unpack_float(vec4 rgba_value)
        {
            const vec4 bit_shift = vec4(1.0/(256.0*256.0*256.0), 1.0/(256.0*256.0), 1.0/256.0, 1.0);
            float value = dot(rgba_value, bit_shift);
            return value;
        }

        bool colorsAreEqual(vec4 color1, vec4 color2) {
            return !(color1.r != color2.r || color1.g != color2.g || color1.b != color2.b);
        }

     	void main(void) {
            if (!OffScreen) {
                float visibility = 1.0;
                vec4 newColor = color;
                vec4 texColor = texture2D(ShadowMap, vec2(shadowCoord.s, shadowCoord.t));
                float z = unpack_float(texColor);
                if(z < shadowCoord.z - 0.005) {
                    newColor *= 0.2;
                    //newColor = texColor;
                }
                /*
                if (colorsAreEqual(newColor, texColor)) {
                    visibility = 0.2;
                    newColor = vec4(visibility, visibility, visibility, 1.0);
                }*/
                newColor.a = 1.0;
                gl_FragColor = newColor;
                //gl_FragColor = pickingColor;
                //gl_FragColor = texColor*color;
                //gl_FragColor = pack_float(shadowCoord.z);
            }
            else {
                //float z = texture2D(ShadowMap, shadowCoord.xy).z;
                gl_FragColor = pack_float(shadowCoord.z);
                //vec4 otherColor = PickingColor;
                //gl_FragColor = otherColor;
            } 
            /*
            if (eye_Value > 0.1 || eye_Value < -0.1) {
            float discrete = floor(pass_Value * steps + 0.5) / steps; //0.5 to round
            gl_FragColor = vec4(heat(discrete), 1.0);
            }
            else {
                gl_FragColor = vec4(0.0, 0.0, 0.0, 1.0);
            }*/
      	}

        
  	</script>

  	<script id="shader-vs" type="x-shader/x-vertex">
        attribute  vec3 vPosition;
        attribute  vec3 vNormal;

		varying vec4 color;
        varying float eye_Value;
        varying float steps;
        varying float pass_Value;
        varying vec4 position;
        varying vec4 shadowCoord;
        varying vec4 pickingColor;
        uniform vec4 AmbientProduct, DiffuseProduct, SpecularProduct;
        uniform mat4 ModelView;
        uniform mat4 Projection;
        uniform vec4 LightPosition;
        uniform float Shininess;
        uniform bool OffScreen;
        uniform bool Picked;
        uniform vec4 PickingColor;
        uniform vec3 EyePosition;
        uniform sampler2D ShadowMap;
        uniform mat4 LightModelView;
        uniform mat4 LightProjection;
        uniform vec2 TexSize;

        void main()
        {
            pickingColor = PickingColor;
            position = vec4(vPosition, 1.0);
            vec4 normal = vec4(vNormal, 0.0);
            mat4 depthBias =  mat4(
                0.5, 0.0, 0.0, 0.0,
                0.0, 0.5, 0.0, 0.0,
                0.0, 0.0, 0.5, 0.0,
                0.5, 0.5, 0.5, 1.0
            );

            if (!OffScreen) {
                // Transform vertex  position into eye coordinates
                vec3 pos = (ModelView * position).xyz;
                vec3 L = normalize( (ModelView * LightPosition).xyz - pos );
                vec3 E = normalize( -pos );
                vec3 H = normalize( L + E );  //halfway vector
    
                // Transform vertex normal into eye coordinates
                vec3 N = normalize( ModelView * normal ).xyz;
    
                //To correctly transform normals
                //vec3 N = (normalize(transpose(inverse(ModelView))*normal).xyz
    
                // Compute terms in the illumination equation
                vec4 ambient = AmbientProduct;
    
                float dr = max( dot(L, N), 0.0 );
                vec4  diffuse = dr *DiffuseProduct;
    
                float sr = pow( max(dot(N, H), 0.0), Shininess );
                vec4  specular = sr * SpecularProduct;
    
                if( dot(L, N) < 0.0 ) {
        	         specular = vec4(0.0, 0.0, 0.0, 1.0);
                }/*
                if (OffScreen || Picked) {
                    color = PickingColor;
                }
                else {*/
                    color = ambient + diffuse + specular;
                    color.a = 1.0;/*
                    vec4 newColor2 = vec4(0.4, 0.35, 0.3, 1.0);
                    vec4 newColor = vec4(0.8, 0.7, 0.6, 1.0);
                    float buckets = 1.0;
                    float intensity = dot(L, N);/*
                    if (intensity < 0.5) {
                        color[0] *= 0.5;
                        color[1] *= 0.5;
                        color[2] *= 0.5;
                        color = newColor2;
                    }
                    else {
                        color = newColor;
                    }*//*
                    color = newColor;
                    pass_Value = intensity;
                    steps = buckets;
                    eye_Value = dot(N, E);*/
                //}
                //color = vec4(0.8, 0.5, 0.6, 1.0);
                //shadowCoord = depthBias * Projection * ModelView * position;
                shadowCoord =  depthBias * LightProjection * LightModelView * position;
                position = Projection * ModelView * position;
                gl_Position = position;
                //gl_Position = position;
                
                
            }
            else {
                shadowCoord =  depthBias * LightProjection * LightModelView * position;
                position = LightProjection * LightModelView * position;
                //shadowCoord = depthBias * Projection * ModelView * position;
                //position = Projection * ModelView * position;
                gl_Position = position;
            }
            
        }
  	</script>
</head>
<body ng-app="myapp">
<div class="container-fluid">
	<div class="row">
		<div class="col-md-3"></div>
		<div class="col-md-5">
			<div class="panel panel-default" ng-controller="CanvasCtrl">
			  	<div class="panel-heading">
			    	<h3 class="panel-title">CS 450: Homework 3|| {{ colorPicked[0] }} {{ colorPicked[1] }} {{ colorPicked[2] }}</h3>
			  	</div>
			  	<div class="panel-body">
			    	<canvas id="hw1-canvas" class="canvas"></canvas>
            <button id="fullscreen" type="button" class="btn btn-default"><span class="glyphicon glyphicon-fullscreen"></span></button>
            <div class="clear"></div>
			  	</div>
			</div>
		</div>
		<div class="col-md-3" ng-controller="FileCtrl">
            <file-drop></file-drop>
            <file-list></file-list>
			<div ng-controller="ViewCtrl">
				<view-nav></view-nav>
				<view-select></view-select>
				<look-at></look-at>
			</div>
		</div>
        <div class="col-md-1"></div>
	</div>
	<div class="row">
		<div class="col-md-3"></div>
		<div class="col-md-6">

		</div>
		<div class="col-md-3"></div>
	</div>
</div>
</body>
</html>
